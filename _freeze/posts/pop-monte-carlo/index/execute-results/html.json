{
  "hash": "235a739941de76b6831554073fdbb059",
  "result": {
    "markdown": "---\ntitle: \"Population Monte Carlo 파퓰레이션 몬테카를로\"\nauthor: \"Jong-Hoon Kim\"\ndate: \"2023-08-10\"\ncategories: [Monte Carlo, R, parameter estimation, code, analysis]\nimage: \"image.jpg\"\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n\n최근에 파티클필터링 (particle filtering; PF) 방법을 이용하여 $\\mathcal{R}_t$ 추정하는 과정에 대한 논문을 썼다. 그런데, 항상 의문이었던 것은 PF를 조금만 변형하면 감염병 모형의 감염속도 $\\beta=\\mathcal{R}_0 \\gamma$ 와 같은 time-invariant 파라미터를 추정할 수도 있지 않을까 하는 것이었다. [Population Monte Carlo (PMC)](https://www.tandfonline.com/doi/abs/10.1198/106186004X12803?journalCode=ucgs20)가 바로 그 방법이었다.\n\n이번 포스트에서는 SIR 모형의 모수 $\\beta$를 PMC 방법으로 추정하여 보았다.\n추정하는 PMC 알고리즘을 아래에 구현하였다. 전에 구현했던 [particle filtering]() 와 유사하다. 즉 중요도 샘플링 (importance sampling)을 연속으로 구현하는 데 연속으로 샘플링 하기 위해 Markov Chain Monte Carlo 에서 사용하듯이 proposal 을 이용하여 다음 단계의 샘플을 만들고 중요도 샘플링을 이용하여 추정을 하는 것이다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(truncnorm) # draw or evaluate according to a truncated normal dist  \npmc <- function (params = NULL,\n                 x0 = NULL, # initial values\n                 y = NULL, # observation\n                 npart = 1000, # number of particles \n                 niter = 10, # iterations\n                 tend = 100, # to control the number of daily y to be fitted\n                 dt = 0.1, # dt for the ODE integration\n                 prior_mean = 0.5,\n                 prior_sd = 2,\n                 prior_lb = 0,\n                 prior_ub = 2) {\n  \n  # makes it easy to use truncated normal distribution\n  nstate <- length(x0) # number of state variables (i.e., S, I, R, CI)\n  \n  # initial betas are sampled according to the prior distribution\n  beta0 <- rtruncnorm(npart, a=prior_lb, b=prior_ub, mean=prior_mean, sd=prior_sd)\n  beta <- matrix(NA, ncol=npart, nrow=niter) # to store the samples for beta\n  beta[1,] <- beta0 # the initial values for the first row\n  # proposal for the next iteration, which is then resampled according to the  weight\n  sd = sd(beta[1,]) # scale for the proposal is adapted according to the current sample \n  beta[2,] = rtruncnorm(npart, a=prior_lb, b=prior_ub, mean=beta[1,], sd=sd)\n  \n  lik <- matrix(NA, ncol = npart, nrow = niter) # likelihood \n  proposal_prob <- matrix(NA, ncol = npart, nrow = niter)\n  wt <- matrix(NA, ncol = npart, nrow = niter) # weight \n  W <- matrix(NA, ncol = npart, nrow = niter) # normalized weights\n  A <- matrix(NA, ncol = npart, nrow = niter) # Resample according to the normalized weight\n  # initial value  \n  proposal_prob[1,] <- 1\n  wt[1,] <- 1 / npart  # initial weights\n  W[1,] <- wt[1,]\n \n  for (i in 2:niter) {\n    # cat(\"i =\", i, \"\\n\")\n    # tend increases by 1 accounts for the initial values\n    X <- array(0, dim = c(npart, tend+1, nstate),\n               dimnames = list(NULL, NULL, names(x0)))\n    for (nm in names(x0)) {# starting values for each particle\n      X[, 1, nm] <- x0[[nm]]\n    }\n    # run process model (i.e., SIR model) \n    x_1_tend <- \n      process_model(params = params,\n                   x = X,\n                   dt = dt,\n                   beta = beta[i,])\n    # calculate weights (likelihood)\n    lik[i,] <- assign_weights(x = x_1_tend, y = y[1:tend])\n    # normalize particle weights\n    proposal_prob[i,] = dtruncnorm(beta[i,], beta[i-1,], a=prior_lb, b=prior_ub, sd=sd)\n    prior_prob = dtruncnorm(beta[i,], a=prior_lb, b=prior_ub, mean=prior_mean, sd=prior_sd)\n    wt[i,] <- lik[i,] * prior_prob / proposal_prob[i,]\n    \n    W[i,] <- wt[i,] / sum(wt[i,])\n    # resample particles by sampling parent particles according to normalized weights\n    A[i,] <- sample(1:npart, prob=W[i,], replace=T)\n    beta[i,] <- beta[i, A[i,]] # resampled beta according to the normalized weight\n    # sd for the proposal can be adapted in various other ways, but we use the sd of the current sample\n    sd = sd(beta[i,]) \n    # generate proposals for the next iteration\n    if (i < niter) {\n      beta[i+1,] <- rtruncnorm(npart, a=prior_lb, b=prior_ub, mean=beta[i,], sd=sd)\n    } \n  } # end iteration\n  return (list(theta=beta, lik=lik, W=W, A=A))\n}\n```\n:::\n\n\n감염병 확산 과정을 나타내는 SIR 모형을 구현해보자. 파티클수에 따라 벡터형태로 SIR 모형을 구현하였다. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nprocess_model <- function (params = NULL,\n                           x = NULL,\n                           dt = 0.1,\n                           beta = NULL) {\n  \n  S <- x[, 1, \"S\"] # a vector of initial S across the particles\n  I <- x[, 1, \"I\"] # a vector of initial I across the particles\n  R <- x[, 1, \"R\"] # a vector of initial S across the particles\n  \n  len <- length(x[1,,\"S\"]) # length of model predictions (same as the data points) + 1 accounting for the initial values\n         \n  N <- S + I + R\n  gamma <- params[[\"gamma\"]]\n  \n  for (j in 2:len) {\n    daily_infected <- 0 # to track the daily infection\n    for (i in seq(dt, 1, dt)) { # steps per day\n      FOI <- beta * I * S/N\n      S_to_I <- FOI * dt\n      I_to_R <- I * gamma * dt\n  \n      S <- S - S_to_I\n      I <- I + S_to_I - I_to_R\n      R <- R + I_to_R\n      \n      daily_infected <- daily_infected + S_to_I\n    }\n    \n    x[, j, \"S\"] <- S\n    x[, j, \"I\"] <- I\n    x[, j, \"R\"] <- R\n    x[, j, \"Inc\"] <- daily_infected\n  }\n  return(x[, 2:len, \"Inc\"])\n}\n```\n:::\n\n\n모수 추정에 사용할 거짓 일별 감염자수를 만들어보자. 위에서 구현한 process_model에서 예측되는 일별 감염자 수를 평균으로 하는 푸아송 분포를 이용하여 만들었다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparm = list(gamma=0.3) #\nx0 = c(S=9990, I=10, R=0, Inc=0)#\ntend = 50 # the number of observations\n# tend + 1 to account for the initial values\nX <- array(0, dim = c(1, tend+1, 4), \n               dimnames = list(NULL, NULL, names(x0)))\nfor (nm in names(x0)) {# starting values for each particle\n  X[, 1, nm] <- x0[[nm]]\n}\ntruebeta <- 0.6 # true beta\npred <- process_model(params=parm, x=X, beta=truebeta)\ny <- rpois(tend, lambda=round(pred))  # \n```\n:::\n\n\npmc 함수에 사용된 또 다른 함수 assign_weights를 아래에 구현하였다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nassign_weights <- function (x, y) {\n  di <- dim(x)\n  npart <- di[1] # number of particles\n  nobs <- di[2] # number of observations\n  loglik <- rep(NA, npart)\n  for (i in 1:npart) {\n    mean_case <- x[i,] # for the ith particle\n    expected_case <- pmax(0, mean_case)\n    obs_case <- round(y)\n    loglik[i] <- sum(dpois(obs_case, lambda=expected_case, log=T), na.rm=T)\n  }\n  return (exp(loglik)) # convert to normal probability\n}\n```\n:::\n\n\nPMC를 이용하여 모수 추정을 해보고 결과를 그림으로 나타내보자.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(44)\n# gamma and x0 are set to the same as the model used to generate the data\nparm = list(gamma=0.3)\nx0 = c(S=9990, I=10, R=0, Inc=0)# initial condition\nniter = 50\n# out = pmc(params = parm, x0 = x0, y=y, npart=10000, niter=niter, \n#    tend = length(y), dt=0.1, prior_mean=0.5, prior_sd=0.1, prior_lb=0,\n#    prior_ub=2)\n# saveRDS(out, \"out_20230811.rds\")\nout <- readRDS(\"out_20230811.rds\")\nhist(out$theta[niter,], xlab=expression(beta), main=\"\")\nabline(v=truebeta, col=2, lwd=2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}