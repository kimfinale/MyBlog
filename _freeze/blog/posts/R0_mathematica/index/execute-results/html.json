{
  "hash": "6504f06f482ec84bfcc531f32f93fcca",
  "result": {
    "markdown": "---\ntitle: \"Basic reproduction number: An algorithmic approach\"\nauthor: \"Jong-Hoon Kim\"\ndate: \"2024-06-02\"\ncategories: [Basic reproduction number, Mathematica, algorithmic approach, next generation matrix]\nimage: \"intro-spikey.png\"\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n\nA [recent article](https://www.mdpi.com/2227-7390/12/1/27) published in Mathematics discusses an approach to calculating $\\mathcal{R}_0$. Since I have previously written a [post](https://www.jonghoonk.com/posts/R0-sympy/) about calculating $\\mathcal{R}_0$ using Sympy, I wanted to explore a new approach proposed by the article.\n\nThe article claims that $\\mathcal{R}_0$ is a not function of the original set of ordinary differential equations (ODEs) because $(F, V)$ gradient decomposition may not be unique for a given set of ODEs. As a reminder, [Diekmann *et al.*](https://link.springer.com/article/10.1007/BF00178324) showed that $\\mathcal{R}_0$ is the spectral radius, or Perron–Frobenius eigenvalue, of the next generation operator.\n\n\n```{=tex}\n\\begin{align}\n\\mathrm{d}S/\\mathrm{d}t &= -\\beta I S/N \\\\\n\\mathrm{d}I/\\mathrm{d}t &= \\beta I S/N - \\gamma I\\\\\n\\mathrm{d}R/\\mathrm{d}t &= \\gamma I\n\\end{align}\n```\n\nFollowing Python and Mathematica codes generate that $$\\mathcal{R}_0 = \\frac{\\beta}{\\gamma}.$$ if $\\beta$ and $\\gamma$ are replaced with $b$ and $g$, respectively.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfrom sympy import *\nb, k, g, = symbols('b k g')\nF = Matrix([[0, b],[0, 0]])\nV = Matrix([[k, 0], [-k, g]])\nM = F*(V**-1)\neigval = M.eigenvals(simplify=true)\ninit_printing(use_unicode=True)\nlst = list(eigval.keys())\nlst[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nb\n─\ng\n```\n:::\n:::\n\n\nMathematica uses the following next generation method (NGM) function provided in the article.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nNGM[mod_, inf_] := \n Module[{dyn, X, infc, M, V, F, F1, V1, K}, dyn = mod[[1]]; \n  X = mod[[2]]; infc = Complement[Range[Length[X]], inf]; \n  M = Grad[dyn[[inf]], X[[inf]]]\n  (*The jacobian of the infectious equations*); \n  V1 = -M /. Thread[X[[infc]] -> 0]\n  (*V1 is a first guess for V,\n  retains all gradient terms which disappear when the non infectious \\\ncomponents are null*); F1 = M + V1\n  (*F1 is a first guess for F,containing all other gradient terms*); \n  F = Replace[F1, _. _?Negative -> 0, {2}];\n  (*all terms in F1 containing minuses are set to 0*); V = F - M;\n  K = (F . Inverse[V]) /. Thread[X[[inf]] -> 0] // FullSimplify;\n  {M, V1, F1, F, V, K}]\n\neqnsSEIR = {\n  -b s i ,\n  b s i - k e,\n  k e - g i, \n  g i }\n\nvarsSEIR = {s, e, i, r}\nmodSEIR = {eqnsSEIR, varsSEIR}\nNGM[modSEIR, {2, 3}] /. s -> 1\n```\n:::\n\n\nAs in the [previous post](https://www.jonghoonk.com/posts/R0-sympy/), I applied the method to the model used in [Pitzer *et al*.](https://journals.plos.org/plosntds/article?id=10.1371/journal.pntd.0002642), of which the model may be expressed in the following set of equations.\n\n\n```{=tex}\n\\begin{align} \n\\mathrm{d}S_1/\\mathrm{d}t &= B + \\epsilon S_2 - (\\lambda_p+\\lambda_w+\\mu)S_1\\\\\n\\mathrm{d}I_1/\\mathrm{d}t &= (\\lambda_p+\\lambda_w)S_1 - (\\delta+\\mu) I_1 \\\\\n\\mathrm{d}R/\\mathrm{d}t &= \\delta(1-\\theta-\\alpha)(I_1+I_2) - (\\omega +\\mu)R \\\\\n\\mathrm{d}C/\\mathrm{d}t &= \\delta\\theta(I_1+I_2) - \\mu C \\\\\n\\mathrm{d}S_2/\\mathrm{d}t &= \\omega R -\\epsilon S_2 - (\\lambda_p+\\lambda_w+\\mu) S_2\\\\\n\\mathrm{d}I_2/\\mathrm{d}t &= (\\lambda_p+\\lambda_w) S_2 - (\\delta+\\mu) I_2 \\\\\n\\mathrm{d}W/\\mathrm{d}t &= \\gamma(I_1+rI_2+rC) - \\xi W\n\\end{align}\n```\n\nFollowing Python and Mathematica codes generates that\n\n\n```{=tex}\n\\begin{align}\n\\mathcal{R}_0 = \\frac{1}{\\mu+\\delta} \\left(\\beta_p +\\frac{\\gamma \\beta_w}{\\xi}\\right) \\left(1 +\\frac{\\delta\\theta r}{\\mu}\\right)\n\\end{align}\n```\n\nIn the following Python codes $p, r, w, d, m, t, g, x$ represent $\\beta_p, r, \\beta_w, \\delta, \\mu, \\theta, \\gamma, \\xi$ in the equation.\n\n\n::: {.cell}\n\n```{.python .cell-code}\np, r, w, d, m, t, g, x = symbols('p r w d m t g x')\nF = Matrix([[p, r*p, r*p, w], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]])\nV = Matrix([[d+m, 0, 0, 0], [0, d+m, 0, 0], [-d*t, -d*t, m, 0], [-g, -r*g, -r*g, x]])\nM = F*(V**-1)\neigval = M.eigenvals(simplify=true)\ninit_printing(use_unicode=True)\neigval \nlst = list(eigval.keys())\nR0_eig = lst[1]\nR0 = (1/(d+m))*(p+g*w/x)*(1+(d*t*r)/m) # R0 from the Pitzer (2014)\nsimplify(R0-R0_eig) # 0 for the same expression (symbolic assessment)\nR0.equals(R0_eig) # True for the same expression (numerical assessment)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\neqnsSIRW = {\n  B + \\[Epsilon] Subscript[s, \n    2] - (Subscript[\\[Beta], \n       P] (Subscript[i, 1] + r Subscript[i, 2] + r c) + \n      Subscript[\\[Beta], W] w + \\[Mu]) Subscript[s, 1],\n  \\[Omega] R - \\[Epsilon] Subscript[s, \n    2] - (Subscript[\\[Beta], \n       P] (Subscript[i, 1] + r Subscript[i, 2] + r c) + \n      Subscript[\\[Beta], W]  w + \\[Mu]) Subscript[s, 2],\n  (Subscript[\\[Beta], P] (Subscript[i, 1] + r Subscript[i, 2] + r c) +\n       Subscript[\\[Beta], W]  w) Subscript[s, \n    1] \\[Minus] (\\[Delta] + \\[Mu]) Subscript[i, 1],\n  (Subscript[\\[Beta], P] (Subscript[i, 1] + r Subscript[i, 2] + r c) +\n       Subscript[\\[Beta], W]  w) Subscript[s, \n    2] - (\\[Delta] + \\[Mu]) Subscript[i, 2],\n  \\[Delta] \\[Theta] (Subscript[i, 1] + Subscript[i, 2]) - \\[Mu] c,\n  \\[Gamma] (Subscript[i, 1] + r Subscript[i, 2] + r c) - \\[Xi] w,\n  \\[Delta] (1 - \\[Theta]) (Subscript[i, 1] + Subscript[i, \n      2]) - (\\[Omega] + \\[Mu]) R}\n\nvarsSIRW = {Subscript[s, 1], Subscript[s, 2], Subscript[i, 1], \n  Subscript[i, 2], c, w, R }\n  \nmodSIRW = {eqnsSIRW, varsSIRW}\nNGM[modSIRW, Range[3, 6]]\n```\n:::\n\n\nAgain, manually defining $F,V$ as follows leads to the same answer\n\n\n::: {.cell}\n\n```{.r .cell-code}\nF = {{Subscript[\\[Beta], P], r Subscript[\\[Beta], P], \n   r Subscript[\\[Beta], P], Subscript[\\[Beta], W] }, {0, 0, 0, 0}, {0,\n    0, 0, 0}, {0, 0, 0, 0}}\nV = {{\\[Delta] + \\[Mu], 0, 0, 0}, {0, \\[Delta] + \\[Mu], 0, \n   0}, {-\\[Delta] \\[Theta], -\\[Delta] \\[Theta], \\[Mu], \n   0}, {-\\[Gamma], -r \\[Gamma], -r \\[Gamma], \\[Xi]}}\nEigenvalues[Dot[F, Inverse[V]]] // FullSimplify\n```\n:::\n\n\n$$\\mathcal{R}_0 = \\frac{(\\mu +\\delta  \\theta  r) \\left(\\xi  \\beta_P+\\gamma  \\beta_W \\right)}{\\mu  \\xi  (\\delta +\\mu )}.$$\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}