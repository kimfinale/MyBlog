{
  "hash": "00b15fcf6173434dafa73f57f4b60adf",
  "result": {
    "markdown": "---\ntitle: \"diffeqr: R interface to the Julia's  DifferentialEquations.jl\"\nauthor: \"Jong-Hoon Kim\"\ndate: \"2024-01-15\"\ncategories: [differential equation, julia, DifferentialEquations.jl, diffeqr]\nimage: \"diffeqr_benchmark.png\"\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n\nJulia [DifferentialEquations.jl](https://docs.sciml.ai/DiffEqDocs/stable/) provides an impressive collection of differential equation solvers. The DE solvers available in the package are reliable and a lot faster than what's avaiable in R. It's now possible to access the solvers in R thanks to the `diffeqr` package. The following codes were adapted from the `diffeqr` GitHub [page](https://github.com/SciML/diffeqr).\n\n### deSolve package\n\nI am using the SIR model as an example and for speed comparison, first solving equations using the [deSolve](https://desolve.r-forge.r-project.org/) package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsir_deSolve <- function(t, u, p){\n  N <- sum(u)\n  du1 <- - p[1]*u[1]*u[2]/N\n  du2 <- + p[1]*u[1]*u[2]/N - p[2]*u[2]\n  du3 <- + p[2]*u[2]\n    \n  return(list(c(du1, du2, du3))) \n}\n```\n:::\n\n\nLet's solve the model using the `deSolve::ode` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(deSolve)\nu0 <- c(99, 1, 0)\ntspan <- seq(from=0, to=50, by=1)\np <- c(0.4, 0.2)\n\noutdf <- as.data.frame(ode(y=u0, times=tspan, func=sir_deSolve, parms=p))\nsaveRDS(outdf, \"outdf.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\noutdf <- readRDS(\"outdf.rds\")\nlibrary(ggplot2)\nextrafont::loadfonts(\"win\", quiet=TRUE)\ntheme_set(hrbrthemes::theme_ipsum_rc(base_size=14, subtitle_size=16, axis_title_size=12))\n\nggplot(outdf,aes(x=time))+\n  geom_line(aes(y=`1`, color=\"S\")) +\n  geom_line(aes(y=`2`, color=\"I\")) +\n  geom_line(aes(y=`3`, color=\"R\")) +\n  scale_color_manual(\"\",values=c(\"S\"=\"steelblue\",\"I\"=\"firebrick\",\n                              \"R\"=\"darkgreen\"))+\n  labs(y=\"Number of individuals\", x=\"Time\", color=\"\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n### diffeqr package\n\nNow let's use the `diffeqr` package. Once the `de <- diffeqr::diffeq_setup` is executed, the functions for DifferentialEquations.jl are available through `de$`. `diffeqr` has slightly different conventions for the ODE model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(diffeqr)\nde <- diffeqr::diffeq_setup()\n\nsir <- function(u, p, t){\n  N = sum(u)\n  du1 = - p[1]*u[1]*u[2]/N\n  du2 = + p[1]*u[1]*u[2]/N - p[2]*u[2]\n  du3 = + p[2]*u[2]\n    \n  return(c(du1,du2,du3))\n}\n\nu0 <- c(100, 1, 0.0)\ntspan <- c(0.0, 50.0)\np <- c(0.4, 0.2)\nprob <- de$ODEProblem(sir, u0, tspan, p)\nsol <- de$solve(prob, de$Tsit5(), saveat=1)\n\nmat <- sapply(sol$u,identity)\nudf <- as.data.frame(t(mat))\ntudf <- cbind(data.frame(t=sol$t), udf)\nsaveRDS(tudf, \"tudf.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntudf <- readRDS(\"tudf.rds\")\ntudflong = tidyr::pivot_longer(tudf, cols=2:4, \n                               names_to=\"var\", \n                               values_to=\"count\")\n\nggplot(tudf,aes(x=t))+\n  geom_line(aes(y=V1, color=\"S\")) +\n  geom_line(aes(y=V2, color=\"I\")) +\n  geom_line(aes(y=V3, color=\"R\")) +\n  scale_color_manual(\"\",values=c(\"S\"=\"steelblue\",\"I\"=\"firebrick\",\n                              \"R\"=\"darkgreen\"))+\n  labs(y=\"Number of individuals\", x=\"Time\", color=\"\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nThe ODE model can be sped up after compiling using the just-in-time (JIT) compiler.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprob_jit <- diffeqr::jitoptimize_ode(de, prob)\n# sol <- de$solve(prob_jit, de$Tsit5(), saveat=1);\n```\n:::\n\n\nThe ODE model can be sped up even further by running it on the GPU. The [GitHub page](https://github.com/SciML/diffeqr) is more geared toward the case in which runing the model multiple times over different initial conditions, which is called ensemble solve. This is why the term ensemble is used below. However, we use the same initial conditions as our sole purpose is to run the model multiple times and compare the elapsed time.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprob_func <- function (prob, i, rep){\n  de$remake(prob, u0=u0, p=p)\n}\nprob_ens <- de$EnsembleProblem(prob_jit, prob_func=prob_func, safetycopy=FALSE)\n# sol <- de$solve(prob_ens, de$Tsit5(), de$EnsembleSerial(), trajectories=1, saveat=1);\n# to take the full advantage we need the following.\ndegpu <- diffeqr::diffeqgpu_setup(\"CUDA\")\n# de$solve(prob_ens, degpu$GPUTsit5(), degpu$EnsembleGPUKernel(degpu$CUDABackend()), trajectories=niter, saveat=1);\n```\n:::\n\n\nI do not describe here but further performance enhancements are possible if your problem can make use of parallel computing.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(microbenchmark)\nniter <- 1e3\n\nbenchmark = microbenchmark(\n  deSolve = ode(y=u0, times=seq(0,50,by=1), func=sir_deSolve, parms=c(0.4,0.3)), \n  diffeqr = de$solve(prob, de$Tsit5(), saveat=1),\n  diffeqr_jit = de$solve(prob_jit, de$Tsit5(), saveat=1),\n  diffeqr_ens = de$solve(prob_ens, de$Tsit5(), de$EnsembleSerial(), trajectories=1, saveat=1),\n  times=niter\n)\n\nbenchmark\nsaveRDS(benchmark, \"benchmark.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbenchmark <- readRDS(\"benchmark.rds\")\nlibrary(dplyr)\nbenchmark |> \n  group_by(expr) |> \n  summarize(lower_sec = quantile(time/1000, probs=0.025),\n            median_sec = quantile(time/1000, probs=0.5),\n            upper_sec = quantile(time/1000, probs=0.975))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 Ã— 4\n  expr        lower_sec median_sec upper_sec\n  <fct>           <dbl>      <dbl>     <dbl>\n1 deSolve         523.       577.       799.\n2 diffeqr         647.       689.       893.\n3 diffeqr_jit      77.9       99.4      166.\n4 diffeqr_ens     168.       214.       332.\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# GPU version requires a different framework to test the speed\nniter <- 1000\ntelapsed_gpu <- system.time(de$solve(prob_ens, degpu$GPUTsit5(), \n                                 degpu$EnsembleGPUKernel(degpu$CUDABackend()), \n                                 trajectories=niter, saveat=1))\nsaveRDS(telapsed_gpu, \"telapsed_gpu.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbenchmark <- readRDS(\"benchmark.rds\")\ntelapsed_gpu <- readRDS(\"telapsed_gpu.rds\")\n\ndf <- data.frame(subroutine=benchmark$expr, time=benchmark$time)\n\nggplot(df) + \n  geom_violin(aes(x=subroutine, y=time))+\n  scale_y_log10(limits=c(0.01, 1e8))+\n  geom_hline(aes(yintercept=telapsed_gpu[3]), color=\"firebrick\")+\n  labs(y=\"Elaspsed time\", x=\"Subroutine\")+\n  coord_flip()+\n  annotate(\"text\", y=telapsed_gpu[3]+5, \n           x=\"diffeqr\",\n           label=\"GPU diffeqr\", color=\"firebrick\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# ggsave(\"diffeqr_benchmark.png\", gg, units=\"in\", width=3.4*2, height=2.7*2)  \n```\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}