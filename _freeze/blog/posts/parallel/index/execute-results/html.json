{
  "hash": "e1aabb03d1b0567a94f01f2da990cc0e",
  "result": {
    "markdown": "---\ntitle: \"Parallel simulation in R\"\nauthor: \"Jong-Hoon Kim\"\ndate: \"2024-06-14\"\ncategories: [parallelism, foreach, doParallel]\nimage: \"right_trunc2.png\"\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n\nI find that `parallel`, `doParallel` and `foreach` packages provide the easiest approach for parallel computing in R. The `doParallel` [vignette](https://cran.r-project.org/web/packages/doParallel/vignettes/gettingstartedParallel.pdf) provides a great overview. `library(doParallel)` command automatically loads required packages.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(doParallel)\nncores <-  detectCores()\ncl <- makeCluster(getOption(\"cl.cores\", ncores/2))\nregisterDoParallel(cl)\nnruns <- ncores\n\nx <- 2\nres <- foreach(i=1:4, .combine=c) %dopar% { c(i, x^2) }\n\nstopCluster(cl)\nres\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 4 2 4 3 4 4 4\n```\n:::\n:::\n\n\nWe can export packages.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncl <- makeCluster(getOption(\"cl.cores\", ncores/2))\nregisterDoParallel(cl)\n\nres <- \n  foreach(i=1:5, .packages=c(\"data.table\"), .combine=cbind) %dopar% {\n    frollmean(rnorm(10), 7)\n  }\n\nstopCluster(cl)\nres\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         result.1   result.2   result.3  result.4     result.5\n [1,]          NA         NA         NA        NA           NA\n [2,]          NA         NA         NA        NA           NA\n [3,]          NA         NA         NA        NA           NA\n [4,]          NA         NA         NA        NA           NA\n [5,]          NA         NA         NA        NA           NA\n [6,]          NA         NA         NA        NA           NA\n [7,]  0.10610803 -0.2996241 0.03278228 0.4701361 -0.004181703\n [8,]  0.05807023 -0.3114088 0.20836936 0.3251219  0.400871629\n [9,]  0.14870568 -0.3538062 0.35330620 0.3301056  0.293785357\n[10,] -0.01413357 -0.4768548 0.19839694 0.2946405 -0.029407561\n```\n:::\n:::\n\n\nWe may want to set the same seed for each worker.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncl <- makeCluster(getOption(\"cl.cores\", ncores/2))\nregisterDoParallel(cl)\n\nres <- \n  foreach(i=1:5, .packages=c(\"data.table\"), .combine=cbind) %dopar% {\n    set.seed(12)\n    frollmean(rnorm(10), 7)\n}\nstopCluster(cl)\nres\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        result.1   result.2   result.3   result.4   result.5\n [1,]         NA         NA         NA         NA         NA\n [2,]         NA         NA         NA         NA         NA\n [3,]         NA         NA         NA         NA         NA\n [4,]         NA         NA         NA         NA         NA\n [5,]         NA         NA         NA         NA         NA\n [6,]         NA         NA         NA         NA         NA\n [7,] -0.6236335 -0.6236335 -0.6236335 -0.6236335 -0.6236335\n [8,] -0.5018746 -0.5018746 -0.5018746 -0.5018746 -0.5018746\n [9,] -0.7423937 -0.7423937 -0.7423937 -0.7423937 -0.7423937\n[10,] -0.5445709 -0.5445709 -0.5445709 -0.5445709 -0.5445709\n```\n:::\n:::\n\n\nDifferent `foreach` sessions with the same random seed are not reproducible.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncl <- makeCluster(getOption(\"cl.cores\", ncores/2))\nregisterDoParallel(cl)\n\nset.seed(12)\na1 <- foreach(i=1:2, combine=cbind) %dopar% { rnorm(5) }\nb1 <- foreach(i=1:2, combine=cbind) %dopar% { rnorm(5) }\nset.seed(12)\na2 <- foreach(i=1:2, combine=cbind) %dopar% { rnorm(5) }\nb2 <- foreach(i=1:2, combine=cbind) %dopar% { rnorm(5) }\nidentical(a1, a2) && identical(b1, b2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nstopCluster(cl)\n```\n:::\n\n\nReproducibility across different `foreach` sessions are possible using \n[doRNG](https://ftp.heanet.ie/mirrors/cran.r-project.org/web/packages/doRNG/index.html) package.\nExamples below were adapted from the [stackoverflow post](https://stackoverflow.com/questions/8358098/how-to-set-seed-for-random-simulations-with-foreach-and-domc-packages).\n\nYou use `%dorng%` instead of `%dopar%` in the `doRNG` approach \n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(doRNG)\n\ncl <- makeCluster(getOption(\"cl.cores\", ncores/2))\nregisterDoParallel(cl)\n\nset.seed(12)\na1 <- foreach(i=1:2, combine=cbind) %dorng% { rnorm(5) }\nb1 <- foreach(i=1:2, combine=cbind) %dorng% { rnorm(5) }\n\nset.seed(12)\na2 <- foreach(i=1:2, combine=cbind) %dorng% { rnorm(5) }\nb2 <- foreach(i=1:2, combine=cbind) %dorng% { rnorm(5) }\nidentical(a1, a2) && identical(b1, b2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nstopCluster(cl)\n```\n:::\n\n\nWe may want to examine parallel workers.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncl <- makeCluster(getOption(\"cl.cores\", ncores/2))\nregisterDoParallel(cl)\ngetDoParWorkers()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10\n```\n:::\n\n```{.r .cell-code}\ngetDoParName()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"doParallelSNOW\"\n```\n:::\n\n```{.r .cell-code}\ngetDoParVersion()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1.0.17\"\n```\n:::\n\n```{.r .cell-code}\nstopCluster(cl)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}