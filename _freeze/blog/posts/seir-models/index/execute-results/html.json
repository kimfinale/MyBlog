{
  "hash": "33c14fbbfc590adf05544ff5c1236a62",
  "result": {
    "markdown": "---\ntitle: \"SEIR model\"\nauthor: \"Jong-Hoon Kim\"\ndate: \"2023-11-09\"\ncategories: [SEIR, deterministic, stochastic, Gillespie's algorithm]\nimage: \"gillespie.png\"\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n\n### Susceptible-Exposed-Infective-Recovered (SEIR) 모형\n\nSEIR 모형은 잠복기가 어느 정도 긴 감염병 (예를 들어 코로나19)의 전파를 모형하는 데 사용한다. 이번 포스트에서는 SEIR 모형을 만드는 방법을 알아본다. 결정론적 (deterministic) 그리고 확률론적 (stochastic) 방법으로 SEIR 모형을 R언어로 만들어 본다.\n\n#### Deterministic model\n\n결정론적 모형은 주로 미분식 (differential equation)을 이용하여 구현한다. $$\\begin{equation} \\begin{split}  \\frac{dS}{dt} &= - \\beta S\\frac{I}{N}\\\\ \\frac{dE}{dt} &= \\beta S\\frac{I}{N} - \\epsilon E\\\\ \\frac{dI}{dt} &= \\epsilon E - \\gamma I\\\\ \\frac{dR}{dt} &= \\gamma I \\end{split} \\end{equation}$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseir_ode <- function(t, y, params) {\n  # state variables \n  S <- y[1]; E <- y[2]; I <- y[3]; R <- y[4];\n  beta <- params[[\"beta\"]] # beta = transmission rate\n  epsilon <- params[[\"epsilon\"]] # 1/epsilon = latent period\n  gamma <- params[[\"gamma\"]] # 1/gamma = duration of infectiousness\n  \n  N <- S + E + I + R # total population size\n  muSE <- beta * S * I / N # rate from S to E\n  muEI <- epsilon * E # rate from E to I, i.e., 1/epsilon = latent period\n  muIR <- gamma * I # rate from I to R\n  \n  dS <- - muSE # rate of change for S\n  dE <- muSE - muEI # rate of change for E\n  dI <- muEI - muIR # rate of change for I\n  dR <- muIR # rate of change for R\n  \n  return(list(c(dS, dE, dI, dR))) # return as a list to use deSolve package\n}\n```\n:::\n\n\n미분식을 적분하여 SEIR 변수들의 시간에 따른 추이를 살펴보자. 적분은 deSolve 패키지의 ode 함수를 이용한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nI0 <- 0.01 # initially infected people\ny0 <- c(S = 1 - I0, E = 0, I = I0, R = 0) # initial values for state variables\nparams <- list() # parameter input for the SIR model\nparams$epsilon <- 0.5\nparams$gamma <- 0.2\nparams$beta <- 0.4  \ntend <- 100 # simulation end time 50 days\ntimes <- seq(0, tend, by = 1) # daily output for 150 days\n\n# ODE integration using the deSolve package\nlibrary(deSolve)\nlibrary(dplyr) # to use %>%\node(y=y0, times=times, func=seir_ode, parms=params) %>%\n  as.data.frame() -> out\nlibrary(tidyr) # turn the data into a long format for easier plot\noutlong <- out %>% pivot_longer(cols=2:5, names_to = \"State\")\n\nlibrary(ggplot2)\ntheme_set(hrbrthemes::theme_ipsum_rc(base_size=14, subtitle_size=16, axis_title_size=12))\nextrafont::loadfonts()\n\nggplot(outlong, aes(x=time, y=value, color=State)) +\n  geom_line(linewidth = 1.2) +\n  labs(x = 'Time (day)', y = 'Proportion')+\n  theme(legend.title = element_blank(),\n        legend.position = \"bottom\") \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\n#### 확률론적 모형\n\n두 가지 방식으로 확률론적 모형을 구현하여 본다. 첫번째는 $\\tau$-leaping 방법과 유사하나 푸아송 분포 대신 binomial 분포를 사용한다. 푸아송 분포와 달리 상한선이 정해지므로 각 상태 변수가 음수로 가는 것을 막을 수 있는 잇점이 있다. S에서 E로 단위 시간 $\\delta$ 동안 이동하는 수는 아래와 같이 정해진다. $$\\begin{equation} \\begin{split}  \\Delta N_{SE} &= \\textrm{Binomial}\\left( S(t), 1-\\textrm{exp}[{-r_{SE}\\delta }]\\right) \\\\ S(t+\\delta) &= S(t) - \\Delta N_{SE}\\ \\end{split} \\end{equation}$$ 비슷한 방법으로 $E$에서 $I$ 그리고 $I$에서 $R$로 변하는 수를 계산하여 아래와 같이 구현한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseir_stoch_step <- function (y, params, delta) {\n  \n  beta <- params[[\"beta\"]]\n  epsilon <- params[[\"epsilon\"]]\n  gamma <- params[[\"gamma\"]] \n\n  S <- y[\"S\"]; E <- y[\"E\"]; I <- y[\"I\"]; R <- y[\"R\"];\n\n  N <- S + E + I + R\n  rSE <- beta * I / N\n  rEI <- epsilon\n  rIR <- gamma\n  # number of events over the time step, delta, modeled as binomial random variable\t\t\n  nSE <- rbinom(1, S, 1 - exp(- rSE * delta))\n  nEI <- rbinom(1, E, 1 - exp(- rEI * delta))\n  nIR <- rbinom(1, I, 1 - exp(- rIR * delta))\n\n  dSdt <- - nSE\n  dEdt <- nSE - nEI\n  dIdt <- nEI - nIR\n  dRdt <- nIR\n  dCEdt <- nSE\n  dCIdt <- nEI\n\n return (list(c(dSdt, dEdt, dIdt, dRdt)))\n}\n```\n:::\n\n\n위 함수는 한 번의$\\delta$동안 변화를 출력하기 때문에 원하는 기간 동안 연속해서 계산하기 위해 아래와 같은 함수를 추가적으로 만든다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstoch_solve <- function(func, y, times, params, delta) {\n  # times indicate the times for which we want to see outputs\n  out <- data.frame(matrix(NA, nrow = length(times), ncol = (length(y)+1)))\n  out[1, ] <- c(times[1], y)\n  row <- 2\n  \n  substeps <- round((times[2]-times[1])/delta)\n  for (t in 1:(length(times)-1)) {\n    for (t2 in 1:substeps) {\n      y <- y + unlist(func(y, params, delta))\n    }\n    out[row, ] <- c(t, y)\n    row <- row + 1\n  }\n  names(out) <- c(\"time\", names(y))\n  return (out)\n}\n```\n:::\n\n\n위 stoch_solve 함수를 이용하여 계산하고 플롯팅을 해본다. ODE 모형의 결과는 proportion으로 주어져 있으니 1,000을 곱한 후 비교하면 결과가 크게 다르지 않음을 알 수 있다. stoch_solve를 여려 번 실행하여 평균을 비교하면 그리고$\\delta$을 작게 할 수록 ODE 모형의 결과와 가까워진다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nres <- stoch_solve(func = seir_stoch_step, y=1000*y0, times=0:100, params = params, delta=0.2)\nreslong <- pivot_longer(res, cols=2:5, names_to = \"State\")\n\nggplot(reslong, aes(x = time, y = value, color = State)) +\n  geom_line(linewidth = 1.2) +\n  labs(x = 'Time (day)', y = 'Number')+\n  theme(legend.title = element_blank(),\n        legend.position = \"bottom\") \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n#### Gillespie algorithm\n\n위에서 기술한 확률론적 방법은 우리가 이미 정한 time interval $\\delta$에 따라 오차가 발생하는 반면 Gillespie algorithm 을 이용해서 통계적으로 정확한 stochastic simulation 을 할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseir_gillespie <- function(y, params) {\n  S <- y[\"S\"]\n  E <- y[\"E\"]\n  I <- y[\"I\"]\n  R <- y[\"R\"]\n  \n  beta <- params[[\"beta\"]]\n  epsilon <- params[[\"epsilon\"]]\n  gamma <- params[[\"gamma\"]]\n  \n  N <- S + E + I + R\n  event_occurred <- FALSE\n  tau <- 0\n  if (I > 0 & S > 0) {## no need to proceed if no one is infectious or no one is susceptible\n    rate_StoE <- beta * S * I / N\n    rate_EtoI <- epsilon * E\n    rate_ItoR <- gamma * I\n    \n    rate_all <- c(rate_StoE, rate_EtoI, rate_ItoR) # event rates\n    tau <- rexp(1, rate = sum(rate_all)) # time to the next event\n    event <- sample(length(rate_all), 1, prob = rate_all) # next event\n    if (event == 1) {\n      S <- S - 1\n      E <- E + 1\n    }\n    else if (event == 2) {\n      E <- E - 1\n      I <- I + 1\n    }\n    else if (event == 3) {\n      I <- I - 1\n      R <- R + 1\n    }\n    event_occurred <- TRUE;\n  }\n  return (list(y = c(S, E, I, R),\n               tau = tau,\n               event_occurred = event_occurred))\n}\n```\n:::\n\n\nseir_gillespie는 한 번의 event 후 결과를 출력하므로 아래와 같이 추가적인 함수를 구성하여 시물레이션을 한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrun_seir_gillespie <- function(func, tend, y, params, report_dt = 1) {\n  res <- data.frame(time = 0, t(y)) # store the simulation results\n  t <- 0\n  yt <- y\n  while (t < tend) {\n    sim <- func(y = yt, params = params) # one event according to the Gillespie algorithm\n    t <- t + sim$tau\n    yt <- sim$y\n    if (t >= report_dt) { # add to the result only when the t is reaches report dt\n      res <- rbind(res, c(t, t(yt)))\n      report_dt <- report_dt  + 1\n    }\n    if (!sim$event_occurred)\n      break\n  }\n  return (res)\n}\n```\n:::\n\n\n시물레이션 결과를 플롯팅 한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nres <- run_seir_gillespie(func = seir_gillespie, \n                     tend = tend, \n                     y = y0 * 1000, \n                     params = params, \n                     report_dt = 1)\n\nreslong <- pivot_longer(res, cols=2:5, names_to = \"State\")\n\nggplot(reslong, aes(x = time, y = value, color = State)) +\n  geom_line(linewidth = 1.2) +\n  labs(x = 'Time (day)', y = 'Number')+\n  theme(legend.title = element_blank(),\n        legend.position = \"bottom\") + \n  ggtitle(\"Gillespie algorithm\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# ggsave(\"gillespie.png\", gg, units=\"in\", width=3.4*2, height=2.7*2)\n```\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}