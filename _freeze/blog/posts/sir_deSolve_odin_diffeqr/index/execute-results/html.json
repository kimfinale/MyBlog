{
  "hash": "3dc635a7ae602f2a24b137f3aeb1f5ef",
  "result": {
    "markdown": "---\ntitle: \"SIR model benchmarks: deSolve, odin, and diffeqr\"\nauthor: \"Jong-Hoon Kim\"\ndate: \"2024-01-19\"\ncategories: [ODE, R, deSolve, odin, diffeqr, C++, Julia]\nimage: \"diffeqr_sir.png\"\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n\n### deSolve package\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsir_deSolve <- function(t, u, p){\n  N <- sum(u)\n  du1 <- - p[1]*u[1]*u[2]/N\n  du2 <- + p[1]*u[1]*u[2]/N - p[2]*u[2]\n  du3 <- + p[2]*u[2]\n    \n  return(list(c(du1,du2,du3))) \n}\n\nlibrary(deSolve)\nu0 <- c(0.99, 0.01, 0)\ntspan <- seq(from=0, to=50)\np <- c(0.4, 0.2)\n\noutdf <- as.data.frame(ode(y=u0, times=tspan, func=sir_deSolve, parms=p))\n\nlibrary(ggplot2)\nextrafont::loadfonts(\"win\", quiet=TRUE)\ntheme_set(hrbrthemes::theme_ipsum_rc(base_size=14, subtitle_size=16, axis_title_size=12))\n\nggplot(outdf,aes(x=time))+\n  geom_line(aes(y=`1`, color=\"S\")) +\n  geom_line(aes(y=`2`, color=\"I\")) +\n  geom_line(aes(y=`3`, color=\"R\")) +\n  scale_color_manual(\"\",values=c(\"S\"=\"steelblue\",\"I\"=\"firebrick\",\n                              \"R\"=\"darkgreen\"))+\n  labs(y=\"Number of individuals\", x=\"Time\", color=\"\")\n```\n:::\n\n\n### Manual C++\n\nEuler method was implemented\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsir_cpp <- '\n#include <Rcpp.h>\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nList sir_cpp(List params) {\n  double tau = params[\"tau\"]; // time step size\n  double ndays = params[\"ndays\"]; // number of days for output\n  int nsubsteps = ceil(1/tau);\n  \n  NumericVector S(ndays+1);\n  NumericVector I(ndays+1);\n  NumericVector R(ndays+1); \n  NumericVector time(ndays+1);\n  \n  S(0) = params[\"susceptible\"];\n  I(0) = params[\"infectious\"];\n  R(0) = params[\"recovered\"];\n  \n  double b = params[\"b\"]; // transmission rate per unit of time\n  double g = params[\"g\"]; // recovery rate\n  \n  for (int day = 0; day < ndays; day++) {\n    double St = S[day];\n    double It = I[day];\n    double Rt = R[day];\n    \n    for (int substep = 0; substep < nsubsteps; substep++){\n      double N = St + It + Rt;\n      double foi = b * It / N;\n\n      double StoI = St * foi * tau;\n      double ItoR = It * g * tau;\n\n      double dS = - StoI;\n      double dI = + StoI - ItoR;\n      double dR = + ItoR;\n\n      St = St + dS;\n      It = It + dI;\n      Rt = Rt + dR;\n    }\n    // Update next timestep\n    S[day + 1] = St;\n    I[day + 1] = It;\n    R[day + 1] = Rt;\n    time[day + 1] = day+1;\n  }\n\n  DataFrame result = DataFrame::create(\n    Named(\"time\") = time,\n    Named(\"S\") = S,\n    Named(\"I\") = I,\n    Named(\"R\") = R);\n\n  return result;\n}'\n\n\nRcpp::cppFunction(code=sir_cpp)\n\nparams <- list()\nparams <- within(params, {\n  tau <- 0.1 # in days\n  ndays <- 50\n\n  b <- 0.4\n  g <- 0.2\n  \n  susceptible <- 0.99\n  infectious <- 0.01\n  recovered <- 0.0\n})\n\nout_cpp <- sir_cpp(params)\n\nggplot(out_cpp, aes(x=time))+\n  geom_line(aes(y=`S`, color=\"S\")) +\n  geom_line(aes(y=`I`, color=\"I\")) +\n  geom_line(aes(y=`R`, color=\"R\")) +\n  scale_color_manual(\"\",values=c(\"S\"=\"steelblue\",\"I\"=\"firebrick\",\n                              \"R\"=\"darkgreen\"))+\n  labs(y=\"Number of individuals\", x=\"Time\", color=\"\")\n```\n:::\n\n\n### odin package\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(odin)\nsir_odin <- odin::odin({\n  ## Derivatives\n  deriv(S) <- -b*S*I/(S+I+R)\n  deriv(I) <- b*S*I/(S+I+R)-g*I\n  deriv(R) <- g*I\n\n  ## Initial conditions\n  initial(S) <- 0.99\n  initial(I) <- 0.01\n  initial(R) <- 0.00\n\n  ## parameters\n  b <- user(0.4)\n  g <- user(0.2)\n})\n\nsir_mod <- sir_odin$new(b=0.4, g=0.2)\ntspan <- seq(from=0, to=50)\nout_odin <- as.data.frame(sir_mod$run(tspan))\n\nggplot(out_odin, aes(x=t))+\n  geom_line(aes(y=`S`, color=\"S\")) +\n  geom_line(aes(y=`I`, color=\"I\")) +\n  geom_line(aes(y=`R`, color=\"R\")) +\n  scale_color_manual(\"\",values=c(\"S\"=\"steelblue\",\"I\"=\"firebrick\",\n                              \"R\"=\"darkgreen\"))+\n  labs(y=\"Number of individuals\", x=\"Time\", color=\"\")\n```\n:::\n\n\n### diffeqr package\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(diffeqr)\nde <- diffeqr::diffeq_setup()\n\nsir_julia <- function(u, p, t){\n  N = sum(u)\n  du1 = - p[1]*u[1]*u[2]/N\n  du2 = + p[1]*u[1]*u[2]/N - p[2]*u[2]\n  du3 = + p[2]*u[2]\n    \n  return(c(du1,du2,du3))\n}\n\nu0 <- c(0.99, 0.01, 0.0)\ntspan <- c(0.0, 50.0)\np <- c(0.4, 0.2)\nprob <- de$ODEProblem(sir_julia, u0, tspan, p)\nprob_jit <- diffeqr::jitoptimize_ode(de, prob)\n\nsol <- de$solve(prob_jit, de$Tsit5(), saveat=1)\n\nmat <- sapply(sol$u, identity)\nudf <- as.data.frame(t(mat))\ntudf <- cbind(data.frame(t=sol$t), udf)\n\nggplot(tudf, aes(x=t))+\n  geom_line(aes(y=V1, color=\"S\")) +\n  geom_line(aes(y=V2, color=\"I\")) +\n  geom_line(aes(y=V3, color=\"R\")) +\n  scale_color_manual(\"\",values=c(\"S\"=\"steelblue\",\"I\"=\"firebrick\",\n                              \"R\"=\"darkgreen\"))+\n  labs(y=\"Number of individuals\", x=\"Time\", color=\"\")\n# ggsave(\"diffeqr_sir.png\", gg, units=\"in\", width=3.4*2, height=2.7*2)  \n```\n:::\n\n\n### Benchmarks\n\nThe `diffeqr` is the most efficient tool for running the SIR model in its ODE form.\n\nAs a side note, the test gave an unfair advantage to the `sir_cpp` due to the use of the Euler method with 0.1 day step size. In fact, `deSolve::ode` outperformed `sir_cpp` when it was used with `method=\"euler\"`. Therefore there is no need to write manually CPP models if an ODE solver is what you need. The situation might differ when implementing a stochastic model, which will be discussed in a later post.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(microbenchmark)\n\nbenchmark = microbenchmark(\n  deSolve = ode(y=u0, times=tspan, func=sir_deSolve, parms=p),\n  cpp = sir_cpp(params),\n  odin = sir_mod$run(tspan),\n  julia = de$solve(prob_jit, de$Tsit5(), saveat=1),\n  times = 1000\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbenchmark <- readRDS(\"benchmark.rds\")\nlibrary(dplyr)\nbenchmark |> \n  group_by(expr) |>\n  mutate(sec=time/1000) |> \n  summarize(\n    lower_sec = quantile(sec, probs=0.025),\n    median_sec = quantile(sec, probs=0.5),\n    upper_sec = quantile(sec, probs=0.975))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 Ã— 4\n  expr    lower_sec median_sec upper_sec\n  <fct>       <dbl>      <dbl>     <dbl>\n1 deSolve      520.       575.     1020.\n2 cpp          228.       309.      639.\n3 odin         199.       285.     1054.\n4 julia        102.       179.      344.\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}