{
  "hash": "30f27de8dad711ba59670f0f7dcf3849",
  "result": {
    "markdown": "---\ntitle: \"LabelledArrays and NamedTupleTools make it easy to use the ODE model in Julia\"\nauthor: \"Jong-Hoon Kim\"\ndate: \"2024-01-26\"\ncategories: [julia, ODE, LabelledArrays, NamedTupleTools, SEIR]\nimage: \"sciml.png\"\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n\n### SEIR model using LabelledArrays\n\nThe [LabelledArrays](https://github.com/SciML/LabelledArrays.jl) package makes it easy to use the ODE model in Julia. It offers a method to manage variables via keys instead of indices. Variables can be constructed using the `@LArray` macro or `LVector`.\n\nHowever, using arrays to store a mix of information types is not optimal for performance. I frequently need to store different variable types within a single parameter, which prompts a warning, highlighting that combining variable types in an array could reduce performance and suggesting tuples as a more efficient alternative.\n\n> ┌ Warning: Utilizing arrays or dictionaries to store parameters of diverse types can compromise performance. │ Using tuples is advised for better efficiency. └ \\@ SciMLBase C:.kim.julia_warnings.jl:32\n\nTuples, being essentially immutable, presents a challenge since some of model parameters that must be adjustible or estimated. The [NamedTupleTools](https://github.com/JeffreySarnoff/NamedTupleTools.jl) package offers a convenient solution with its `merge` function, enabling easy updates to the values within a Tuple.\n\nIn conclusion, the best approach seems to be leveraging LabelledArrays for state variables and NamedTupleTools for parameters. Let's delve into this approach using the SEIR model as a case study.\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nusing LabelledArrays, OrdinaryDiffEq, Plots, NamedTupleTools, BenchmarkTools\n\nfunction seir(du, u, p, t)\n    N = sum(u)\n    du.S = - p.β * u.S * u.I / N\n    du.E = + p.β * u.S * u.I / N - p.ϵ * u.E\n    du.I = + p.ϵ * u.E - p.γ* u.I\n    du.R = + p.γ* u.I \nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nseir (generic function with 1 method)\n```\n:::\n\n```{.julia .cell-code}\n\nu0 = @LArray [0.99, 0.0, 0.01, 0.0] (:S, :E, :I, :R);\np_la = @LArray [0.5, 1/2, 1/4] (:β, :ϵ, :γ);\np_la = LVector(p_la, β=0.8, str=\"string\", int=9, la=LVector(a=1,b=2,c=3), tp=(a=1,b=2,c=3));\ntspan = (0.0, 100.0);\nprob = ODEProblem(seir, u0, tspan, p_la);\nsol = solve(prob, Tsit5(), saveat=1);\n\ns = [sol[i].S for i in 1:101];\ne = [sol[i].E for i in 1:101];\ni = [sol[i].I for i in 1:101];\nr = [sol[i].R for i in 1:101];\n\nplot(sol.t, [s e i r])\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-J1.png){width=300}\n:::\n\n```{.julia .cell-code}\n\n# NamedTupleTools approach\np_nt = (β=0.5, ϵ=1/2, γ=1/4);\np_nt = merge(p_nt, (β=0.8, str=\"string\", int=9, la=LVector(a=1,b=2,c=3), tp=(a=1,b=2,c=3)));\n\nusing BenchmarkTools\ntime_la = @benchmark solve(ODEProblem(seir, u0, tspan, p_la), Tsit5(), saveat=1);\ntime_nt = @benchmark solve(ODEProblem(seir, u0, tspan, p_nt), Tsit5(), saveat=1);\ntime_la\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBenchmarkTools.Trial: 10000 samples with 1 evaluation.\n Range (min … max):  180.800 μs … 345.339 ms  ┊ GC (min … max): 0.00% … 99.84%\n Time  (median):     234.550 μs               ┊ GC (median):    0.00%\n Time  (mean ± σ):   400.856 μs ±   3.459 ms  ┊ GC (mean ± σ):  9.26% ±  3.45%\n\n  █▅▃▃▂▂▁ ▄▁ ▄▃▁ ▃▂▄▃▃▃▂▂▁▁▁▁▁                                  ▁\n  █████████████████████████████████▇▇▇▇▆▆▅▆▅▅▃▅▅▅▅▅▄▅▅▅▄▅▅▅▄▅▅▅ █\n  181 μs        Histogram: log(frequency) by time       1.35 ms <\n\n Memory estimate: 107.62 KiB, allocs estimate: 5775.\n```\n:::\n\n```{.julia .cell-code}\ntime_nt\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBenchmarkTools.Trial: 10000 samples with 1 evaluation.\n Range (min … max):   59.800 μs … 273.123 ms  ┊ GC (min … max):  0.00% … 99.92%\n Time  (median):      91.100 μs               ┊ GC (median):     0.00%\n Time  (mean ± σ):   161.812 μs ±   2.731 ms  ┊ GC (mean ± σ):  16.86% ±  1.00%\n\n  █▇▆▆▆▄▂▁▂▂ ▃▅▆▄▄▂▃▃▃▂▂▃▂▁▁▂▂▂▁▁▁▁▁ ▁▁                         ▂\n  ████████████████████████████████████████▇██▇▆▆▇▆▆▆▄▄▅▆▆▆▅▄▃▅▅ █\n  59.8 μs       Histogram: log(frequency) by time        483 μs <\n\n Memory estimate: 29.45 KiB, allocs estimate: 730.\n```\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}