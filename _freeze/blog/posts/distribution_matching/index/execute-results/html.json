{
  "hash": "7fc099b5710438196bc4b0f2ed7cb3a7",
  "result": {
    "markdown": "---\ntitle: \"Distribution Matching Methods: From Theory to Practice\"\nauthor: \"Jong-Hoon Kim\"\ndate: \"2024-10-31\"\nformat:\n  html:\n    code-fold: false\n    toc: true\n    toc-depth: 3\n    number-sections: true\n    highlight-style: github\n    fig-width: 8\n    fig-height: 6\nexecute:\n  echo: true\n  warning: false\n  message: false\n---\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load required packages\nlibrary(MASS)\nlibrary(ks)\nlibrary(ggplot2)\nlibrary(patchwork)\nlibrary(tidyr)\nlibrary(dplyr)\n```\n:::\n\n\n# Introduction\n\nWhen working with data from different sources or distributions, we often need to transform one distribution to match another. In this post, we'll explore various methods for distribution matching, implement them in R, and discuss their strengths and limitations.\n\n# Distribution Matching Methods\n\n## Quantile Matching\n\nQuantile matching transforms data by mapping corresponding quantiles between distributions. It's a non-parametric approach that preserves the rank order of the original data.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nquantile_match <- function(A, B) {\n  probs <- seq(0, 1, length.out = length(A))\n  sorted_A <- sort(A)\n  \n  B_transformed <- approx(x = probs,\n                         y = sorted_A,\n                         xout = rank(B)/(length(B) + 1),\n                         method = \"linear\")$y\n  return(B_transformed)\n}\n```\n:::\n\n\n## Box-Cox Transformation\n\nThe Box-Cox transformation is particularly useful when you want to transform data to approximate normality before matching moments.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nboxcox_match <- function(A, B) {\n  # Find optimal lambda for both distributions\n  bc_A <- boxcox(A ~ 1, plotit = FALSE)\n  lambda_A <- bc_A$x[which.max(bc_A$y)]\n  \n  # Transform to normality\n  transform_boxcox <- function(x, lambda) {\n    if (abs(lambda) < 1e-4) {\n      log(x)\n    } else {\n      (x^lambda - 1) / lambda\n    }\n  }\n  \n  # Transform both samples\n  A_transformed <- transform_boxcox(A, lambda_A)\n  B_transformed <- transform_boxcox(B, lambda_A)  # Use same lambda\n  \n  # Match moments\n  B_standardized <- (B_transformed - mean(B_transformed)) / sd(B_transformed)\n  B_matched <- B_standardized * sd(A_transformed) + mean(A_transformed)\n  \n  # Inverse transform\n  inverse_boxcox <- function(x, lambda) {\n    if (abs(lambda) < 1e-4) {\n      exp(x)\n    } else {\n      (lambda * x + 1)^(1/lambda)\n    }\n  }\n  \n  B_final <- inverse_boxcox(B_matched, lambda_A)\n  return(B_final)\n}\n```\n:::\n\n\n## Kernel Density-Based Transformation\n\nThis method uses kernel density estimation to transform the distributions.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nkernel_density_match <- function(A, B, bw = \"nrd0\") {\n  # Estimate densities\n  density_A <- kde(A, h = bw.nrd0(A))\n  density_B <- kde(B, h = bw.nrd0(B))\n  \n  # Calculate CDFs using numerical integration\n  cdf_A <- function(x) {\n    sapply(x, function(xi) {\n      mean(pnorm(xi, A, density_A$h))\n    })\n  }\n  \n  cdf_B <- function(x) {\n    sapply(x, function(xi) {\n      mean(pnorm(xi, B, density_B$h))\n    })\n  }\n  \n  # Transform B to match A's distribution\n  B_probs <- cdf_B(B)\n  \n  # Create quantile function for A using interpolation\n  A_sorted <- sort(A)\n  A_probs <- cdf_A(A_sorted)\n  \n  B_transformed <- approx(x = A_probs,\n                         y = A_sorted,\n                         xout = B_probs,\n                         yleft = min(A),\n                         yright = max(A))$y\n  \n  return(B_transformed)\n}\n```\n:::\n\n\n## Moment Matching\n\nA simpler approach that focuses on matching the first two moments of the distributions.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nmoment_match <- function(A, B) {\n  # Standardize B\n  B_std <- (B - mean(B)) / sd(B)\n  \n  # Transform to match A's moments\n  B_transformed <- B_std * sd(A) + mean(A)\n  \n  return(B_transformed)\n}\n```\n:::\n\n\n# Comparing the Methods\n\nLet's generate some sample data and compare all methods:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\n# Set seed for reproducibility\nset.seed(123)\n\n# Generate sample data\nA <- rnorm(1000, mean = 10, sd = 2)  # Normal distribution\nB <- rexp(1000, rate = 0.1)          # Exponential distribution\n\n# Apply all transformations\nB_quantile <- quantile_match(A, B)\nB_boxcox <- boxcox_match(A, B)\nB_kernel <- kernel_density_match(A, B)\nB_moment <- moment_match(A, B)\n```\n:::\n\n\n## Visual Comparison\n\nLet's create a more elegant visualization using ggplot2:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a data frame for plotting\ndf <- data.frame(\n  Original_A = A,\n  Original_B = B,\n  Quantile = B_quantile,\n  BoxCox = B_boxcox,\n  Kernel = B_kernel,\n  Moment = B_moment\n)\n\n# Convert to long format\ndf_long <- pivot_longer(df, \n                       cols = everything(),\n                       names_to = \"Method\",\n                       values_to = \"Value\")\n\n# Create the plot\nggplot(df_long, aes(x = Value, fill = Method)) +\n  geom_density(alpha = 0.5) +\n  facet_wrap(~Method, scales = \"free_y\", ncol = 2) +\n  theme_minimal() +\n  labs(x = \"Value\",\n       y = \"Density\",\n       title = \"Comparison of Distribution Matching Methods\",\n       subtitle = \"Original A (target) vs Original B and transformed distributions\") +\n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![Comparison of Distribution Matching Methods](index_files/figure-html/visualization-1.png){width=960}\n:::\n:::\n\n\n## Numerical Comparison\n\nLet's compare some summary statistics:\n\n\n::: {.cell tbl-cap='Summary Statistics Comparison'}\n\n```{.r .cell-code}\n# Function to calculate summary statistics\nget_stats <- function(x) {\n  c(Mean = mean(x),\n    SD = sd(x),\n    Median = median(x),\n    Skewness = mean((x - mean(x))^3) / sd(x)^3,\n    Kurtosis = mean((x - mean(x))^4) / sd(x)^4)\n}\n\n# Calculate statistics for all distributions\nstats_df <- data.frame(\n  Original_A = get_stats(A),\n  Original_B = get_stats(B),\n  Quantile = get_stats(B_quantile),\n  BoxCox = get_stats(B_boxcox),\n  Kernel = get_stats(B_kernel),\n  Moment = get_stats(B_moment)\n)\n\n# Display the results\nknitr::kable(round(stats_df, 3))\n```\n\n::: {.cell-output-display}\n|         | Original_A| Original_B| Quantile| BoxCox| Kernel| Moment|\n|:--------|----------:|----------:|--------:|------:|------:|------:|\n|Mean     |     10.032|      9.837|   10.031| 10.031| 10.093| 10.032|\n|SD       |      1.983|      9.720|    1.967|  2.011|  1.872|  1.983|\n|Median   |     10.018|      6.684|   10.018|  9.424|  9.989|  9.389|\n|Skewness |      0.065|      1.686|    0.057|  1.532|  0.444|  1.686|\n|Kurtosis |      2.920|      6.075|    2.842|  5.459|  2.736|  6.075|\n:::\n:::\n\n\n# Method Selection Guide\n\nEach method has its strengths and appropriate use cases:\n\n## Quantile Matching\n- **Pros**: Preserves rank order, works with any distribution\n- **Cons**: May not extrapolate well\n- **Best for**: General-purpose distribution matching\n\n## Box-Cox Transformation\n- **Pros**: Works well for skewed data, preserves relationships\n- **Cons**: Requires positive data, assumes underlying normality\n- **Best for**: Right-skewed positive data\n\n## Kernel Density-Based\n- **Pros**: Highly flexible, handles multimodal distributions\n- **Cons**: Computationally intensive, sensitive to bandwidth selection\n- **Best for**: Complex, multimodal distributions\n\n## Moment Matching\n- **Pros**: Simple, fast, preserves linear relationships\n- **Cons**: Only matches first two moments, assumes similar shapes\n- **Best for**: Nearly normal distributions or quick approximations\n\n# Performance Comparison\n\nLet's compare the computational performance of these methods:\n\n\n::: {.cell hash='index_cache/html/performance_127a6a95bd68cc1ff47ab3193ac9d115'}\n\n```{.r .cell-code}\nlibrary(microbenchmark)\n\n# Benchmark the methods\nbench <- microbenchmark(\n  Quantile = quantile_match(A, B),\n  BoxCox = boxcox_match(A, B),\n  Kernel = kernel_density_match(A, B),\n  Moment = moment_match(A, B),\n  times = 100\n)\n\n# Plot results\nautoplot(bench) +\n  theme_minimal() +\n  labs(title = \"Performance Comparison\",\n       subtitle = \"Time taken by each method (lower is better)\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/performance-1.png){width=768}\n:::\n:::\n\n\n# Conclusion\n\nWhile quantile matching is often the default choice for distribution matching, having multiple approaches in your toolkit allows you to handle various scenarios more effectively. The choice of method should depend on:\n\n1. Your data characteristics\n2. Computational resources\n3. Preservation requirements\n4. Desired properties of the transformed distribution\n\nAlways validate your transformations through both visual inspection and numerical summaries to ensure the transformed distribution meets your requirements.\n\n# References\n\n- Box, G. E. P., & Cox, D. R. (1964). An analysis of transformations. Journal of the Royal Statistical Society: Series B (Methodological), 26(2), 211-243.\n- Silverman, B. W. (1986). Density estimation for statistics and data analysis. CRC press.\n- Bolstad, B. M., Irizarry, R. A., Ã…strand, M., & Speed, T. P. (2003). A comparison of normalization methods for high density oligonucleotide array data based on variance and bias. Bioinformatics, 19(2), 185-193.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}