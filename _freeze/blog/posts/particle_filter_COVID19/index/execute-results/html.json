{
  "hash": "193e478cc300e5416235ff687ad41895",
  "result": {
    "markdown": "---\ntitle: \"Estimating the instantaneous reproduction number using the particle filter\"\nauthor: \"Jong-Hoon Kim\"\ndate: \"2023-8-19\"\ncategories: [particle filter, COVID-19]\nimage: \"particle_filter_covid.png\"\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n\n### A simple particle filter in R\n\n파티클 필터 (particle filter) 를 이용하여 잠재 변수 (latent variable)를 추정하는 과정을 지난 글에서 다루었다.  관찰값들이 코로나 19 일별 감염자일때 감염병 수리 모형을 이용하여 일별 감염재생산지수 ($(R_t$) 를 추정한다. 아래 글은 2020년 Kucharski et al. 논문에 사용되었던 방법을 차용하였다. 이해를 돕기 위해 모형을 단순화 하였고 가상의 데이타를 만들어 내는 과정을 더하였다. \n우선 SEIR 모형을 이용해서 가상의 데이타 (일별 감염자 수)를 만든다. 누적 감염자 (cumulative incidence) 를 나타내는 CI라는 변수의 일별 차이를 계산하여 일별 감염자 수를 계산한다. 보통의 SEIR 모형에서는 $\\beta$가 상수로 취급 되지만 아래 모형에서는 일별 감염 재생산지수 $R_t = \\beta (t) \\times D$ $D$는 감염 기간)가 방역 정책, 활동 변화 등 이유로 인해 시간에 따라 변화한다고 가정하기 때문에 시간에 따른 함수 $\\beta(t)$로 표현한다.  우리가 추정 하고자 하는 $R_t$를 미리 정의하고 이로 부터 $\\beta(t)$ 를 계산하고 이를 SEIR 모형에 적용하여 가상의 데이타를 만든다.    \n아래와 같은 방식으로 SEIR 모형을 만든다. 본래 미분식으로 정의하고 `deSolve` 패키지의 `ode` 함수 등을 이용하여 적분할 수 있으나 이 글에서는 간단하게 Euler 방법을 사용한다. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nSEIR_Euler <- function (params = NULL,\n                        y = NULL,\n                        tbegin = 0,\n                        tend = 1,\n                        dt = 0.2) {\n  \n  M <- matrix(NA, nrow=(tend-tbegin+1), ncol=length(y)) # output matrix\n  M[1,] <- y # initial values for the first row\n  \n  S <- y[1]; E <- y[2]; I <- y[3]; R <- y[4]; CI <- y[5]\n  N <- S + E + I + R\n  epsilon <- params[[\"epsilon\"]]\n  gamma <- params[[\"gamma\"]]\n  Rt <- params[[\"Rt\"]] # daily reproduction number\n  \n  for (t in seq(tbegin, tend, by=1)) { # for each day\n    for (i in seq(dt, 1, dt)) { # sub-intervals that can vary\n      # beta is already adjusted by N \n      # t is not an integer\n      beta <- Rt[floor(t+1+dt)] * gamma # transmission rate\n      S_to_E <- beta * I * dt\n      E_to_I <- E * epsilon * dt\n      I_to_R <- I * gamma * dt\n      \n      # update state variables\n      S <- S - S_to_E\n      E <- E + S_to_E - E_to_I\n      I <- I + E_to_I - I_to_R\n      R <- R + I_to_R\n      CI <- CI + S_to_E\n    }\n    # output for each day\n    M[t+1, 1] <- S \n    M[t+1, 2] <- E\n    M[t+1, 3] <- I\n    M[t+1, 4] <- R\n    M[t+1, 5] <- CI\n  }\n  return(M)\n}\n```\n:::\n\n\n일별 감염자 수를 플롯해본다.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# pre-defined Rt\nRt_true <- c(rep(1.2, 15), 0.5*sin(0.1*pi*0:32) + 1.2, rep(0.9, 100))\nI0 <- 100 # initially infected people\ny0 <- c(S = 1e7-I0, E = 0, I = I0, R = 0, CI = 0) # initial values for state variables\nparams <- list() # input parameters for the SEIR model\nparams$Rt <- Rt_true\nparams$epsilon <- 0.5 # 1/epsilon = latent period\nparams$gamma <- 0.2 # 1/gamma = duration of infectiousness\ntend <- 50 # simulation end time 50 days\n\nres1 <- SEIR_Euler(params = params, y=y0, tend=50) # run the model\nres1 <- as.data.frame(res1)\nres1$daily_infected <- c(0, diff(res1$V5))\nres1$time <- 0:tend\n\nlibrary(ggplot2)\nextrafont::loadfonts(\"win\", quiet=TRUE)\ntheme_set(hrbrthemes::theme_ipsum_rc(base_size=14, subtitle_size=16, axis_title_size=12))\n\nggplot(res1, aes(x = time, y = daily_infected)) +\n  geom_line(size = 1.2) +\n  labs(x = 'Time (day)', y = 'Daily infected')\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\n푸아송 분포를 이용하여 가상의 데이타를 만든다. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create the data assunming observations are poisson random variable\nset.seed(42)\nfakedata <- data.frame(daily_infected = rpois(nrow(res1), lambda = res1$daily_infected))\n```\n:::\n\n\n일별 변화를 계산하는 SEIR 전파 모형, 행의 수는 파티클 수와 같다. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# stochastic differential equation (with beta(t) moves according to a geometric Brownian motion) are modeled using the Euler-Maruyama method.\n# daily change is modeled using the subinterval dt\nSEIR_step <- function (params = NULL,\n                       y = NULL,\n                       tbegin = 0,\n                       tend = 1,\n                       dt = 0.2,\n                       beta = NULL) {\n  # daily infection reset to zero to hold values from tbegin to tend\n  y[, c(\"CI\")] <- 0\n  \n  S <- y[, \"S\"]\n  E <- y[, \"E\"]\n  I <- y[, \"I\"]\n  R <- y[, \"R\"]\n  daily_infected <- y[, \"CI\"]\n  \n  N <- S + E + I + R\n  epsilon <- params[[\"epsilon\"]]\n  gamma <- params[[\"gamma\"]]\n  \n  for (i in seq((tbegin + dt), tend, dt)) {\n    # beta is already assumed to be adjusted by N such that it can\n    # be translated to Rt by multiplying the duration of infectiousness\n    S_to_E <- beta * I * dt\n    E_to_I <- E * epsilon * dt\n    I_to_R <- I * gamma * dt\n    # Process model for SEIR\n    S <- S - S_to_E\n    E <- E + S_to_E - E_to_I\n    I <- I + E_to_I - I_to_R\n    R <- R + I_to_R\n    daily_infected <- daily_infected + S_to_E\n  }\n  y[, \"S\"] <- S\n  y[, \"E\"] <- E\n  y[, \"I\"] <- I\n  y[, \"R\"] <- R\n  y[, \"CI\"] <- daily_infected\n  \n  return(y)\n}\n```\n:::\n\n\n파티클 필터링 함수 \n\n\n::: {.cell}\n\n```{.r .cell-code}\npfilter <- function (params, # parameters\n                     y, # initial values of state variables\n                     data, # input data set\n                     npart = 1000, # number of particles\n                     tend = NULL, # simulation stop time\n                     dt = 0.2) {\n  \n  # Assumptions - using daily growth rate\n  nstatevar <- length(y) # number of state variables\n  if(is.null(tend)) {\n    tend = nrow(data)\n  }\n  # to store state variables\n  latent_var <- array(0,\n                      dim = c(npart, tend, nstatevar),\n                      dimnames = list(NULL, NULL, names(y)))\n  # latent_var[, 1, ] <- y\n  for (nm in names(y)) { # initial value\n    latent_var[, 1, nm] <- y[[nm]]\n  }\n  ## parameters \n  gamma <- params[[\"gamma\"]]\n  beta0 <- params[[\"R0\"]] * gamma\n  beta_sd <- params[[\"betavol\"]]\n  beta <- matrix(rnorm(npart * tend, mean = 0, sd = beta_sd), nrow = tend)\n  beta[1,] <- beta0 # this is updated at t=2\n  \n  wt <- matrix(NA, nrow = npart, ncol = tend) # weight (likelihood)\n  wt[, 1] <- 1 / npart  # initial weights\n  W <- matrix(NA, nrow = npart, ncol = tend) # normalized weights\n  A <- matrix(NA, nrow = npart, ncol = tend) # Resample according to the normalized weight\n  \n  for (t in 2:tend) {# begin particle loop\n    # beta changes according to a Geometric Brownian motion \n    beta[t, ] <- beta[t-1, ] * exp(beta[t, ])\n    # run process model\n    latent_var[, t, ] <- SEIR_step(params = params,\n                                   y = latent_var[, t-1, ],\n                                   tbegin = t-1,\n                                   tend = t,\n                                   dt = dt,\n                                   beta = beta[t,])\n    # calculate weights (likelihood)\n    # wt[, t] <- assign_weights(var = latent_var, t = t, data = data)\n    \n    case_expected <- latent_var[, t, \"CI\"]\n    case_data <- round(unlist(data[t, \"daily_infected\"]))\n    expected_val <- pmax(0, case_expected) # make sure that the value is not negative\n    log_lik <- dpois(round(case_data), lambda = expected_val, log = T)\n    wt[, t] <- exp(log_lik)\n    # normalize particle weights\n    W[, t] <- wt[, t] / sum(wt[, t])\n    # resample particles by sampling parent particles according to weights\n    A[, t] <- sample(1:npart, prob = W[1:npart, t], replace = T)\n    # Resample particles for corresponding variables\n    latent_var[, t,] <- latent_var[A[, t], t,]\n    beta[t,] <- beta[t, A[, t]] #- needed for random walk on beta\n  } # end particle loop\n  \n  # Marginal likelihoods\n  lik_values <- rep(NA, tend)\n  for (t in 1:tend) {\n    lik_values[t] <- log(sum(wt[1:npart, t])) # log-likelihoods\n  }\n  # averaged log likelihoods log(L/(npart^tend))\n  loglik <- - tend * log(npart) + sum(lik_values)\n  \n  return (list(lik_marginal = lik_values,\n               lik_overall_average = loglik,\n               latent_var_filtered = latent_var,\n               beta_filtered = beta,\n               W = W, A = A))\n}\n```\n:::\n\n\n\n일별 변화를 계산하는 SEIR 전파 모형, 행의 수는 파티클 수와 같다. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nparams$R0 <- 2\nparams$betavol <- 0.3\nsample <- pfilter(params=params, # parameters\n                     y=y0, # initial values of state variables\n                     data=fakedata, # input data set\n                     npart = 1000, # number of particles\n                     tend = tend, # simulation stop time\n                     dt = 0.2) \nobserved <- fakedata$daily_infected[2:nrow(fakedata)]\n```\n:::\n\n\n#### Plot the results\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# draw incidence plot\ndaily_inc_summary <- t(apply(sample$latent_var_filtered[,,5], 2, quantile,\n            probs=c(0.025, 0.5, 0.975)))\ndf <- cbind(data.frame(time=1:(nrow(res1)-1), observed = observed), daily_inc_summary)\n\n\nggplot(df, aes(x=time)) +\n  geom_ribbon(aes(ymin=`2.5%`, ymax=`97.5%`), fill=\"steelblue\", alpha=0.8)+\n  geom_line(aes(y=`50%`), color=\"steelblue\")+\n  geom_point(aes(y=observed), color = \"darkred\")+\n  labs(x=\"Time\", y=\"Daily incidence\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# draw daily Rt plot\ndur <- 1/params$gamma\ndaily_Rt_summary <- t(apply(sample$beta_filtered * dur, 1, quantile,\n                            probs=c(0.025, 0.5, 0.975)))  \ndf <- cbind(data.frame(time=1:(nrow(res1)-1), true_Rt = Rt_true[2:51]), daily_Rt_summary)\nggplot(df, aes(x=time)) +\n  geom_ribbon(aes(ymin=`2.5%`, ymax=`97.5%`), fill=\"darkgreen\", alpha=0.7)+\n  geom_line(aes(y=`50%`), color=\"darkgreen\")+\n  geom_point(aes(y=true_Rt), color = \"black\") + \n  labs(x=\"Time\", y=expression(italic(R[t])))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-2.png){width=672}\n:::\n\n```{.r .cell-code}\n# ggsave(\"particle_filter_covid.png\", gg, units=\"in\", width=3.4*2, height=2.7*2)\n```\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}