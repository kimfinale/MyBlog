{
  "hash": "fc056f900e631a630e78f609c897df82",
  "result": {
    "markdown": "---\ntitle: \"SEIR model using the Nimble pacakge\"\nauthor: \"Jong-Hoon Kim\"\ndate: \"2023-06-19\"\ncategories: [nimble, MCMC, posterior predictive check, trace plot]\nimage: \"nimble_ppc_incidence.png\"\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n\n감염병 수리 모형을 개발하는 데 있어 가장 근본적인 질문 중 하나는 주어진 관찰값 (시계열)하에서 어떤 모형을 선택하고 그 모수의 값을 어떻게 결정하는가이다. 모형을 선택하는 과정은 따로 다루기로 하고 여기서는 일반적으로 사용되는 감염병 수리 모형 (i.e., SIR)을 사용할 때 모수를 추정하는 과정에 대해서 이야기해보자. 최대 가능도 (maximum likelihood) 방법에 대해서는 전에 언급하였다. \n모수를 추정하는 여러 방법 중에 마르코프 연쇄 몬테카를로 (Markov Chain Monte Carlo; MCMC) 방법이 적절한 모수의 값을 찾아내고 그 값의 불확실성 (uncertainty)를 나타내는 데 가장 널리 쓰이는 방법 중의 하나이다. MCMC 알고리듬을 직접 작성해서 사용한는 것도 원리를 이해하는 데에는 도움이 되지만 이미 다양한 통계 패키지에서 MCMC가 사용되고 있으므로 기존 패키지를 사용하는 것도 합리적인 방법이 될 수 있다. 회귀 분석 등 통계모형의 경우BUGS (Bayesian Inference Using Gibbs Sampling) 혹은 JAGS (Just Another Gibbs Sampler), Stan, 그리고 NIMBLE 등에 구현된 MCMC를 사용하는 것이 많이 보편화 되어 있다.  \n이 중 NIMBLE 은 R 패키지 nimble을 이용해서 사용할 수 있고 패키지에서 제공하는 함수 기능을 이용해서 감염병 수리 모형을 구현하고 MCMC 까지 할 수 있다. syntax 또한 R과 유사해서 R를 사용하는 사람에게는 Stan 보다 더 접근이 용이한 것 같다. 아래에는 nimble 함수 기능을 이용하여 Euler 방법에 기반한 SIR 모형을 구현한 예이다.    \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(nimble)\nsir_incidence <- nimbleFunction(\n  run = function(beta = double(0)) {\n    tend <- 100 # 100 days of simulation\n    dt <- 0.1 # time step of 0.1 day\n    \n    # initial condition\n    St <- 999 \n    It <- 1\n    Rt <- 0\n    CIt <- 0\n    \n    # create vectors for the state variables\n    S <- rep(0, tend)\n    I <- rep(0, tend)\n    R <- rep(0, tend) \n    CI <- rep(0, tend) # cumulative incidence\n    \n    # first elements of the vectors are initial conditions\n    S[1] <- St\n    I[1] <- It\n    R[1] <- Rt\n    CI[1] <- CIt\n  \n    gamma <- 0.2 # 1/gamma = duration of infectiousness\n    \n    for (i in 2:tend) { # each day\n      for (j in 1:ceiling(1/dt)) { # time steps per day\n        Nt <- St + It + Rt                     # total population size\n        rate_StoI <- St * beta * It / Nt * dt  # transition rate from S to I\n        rate_ItoR <- gamma * It * dt           # transition rate from I to R\n  \n        dS <- - rate_StoI            # rate of change for S\n        dI <- rate_StoI - rate_ItoR  # rate of change for I\n        dR <- rate_ItoR              # rate of change for R\n        dCI <- rate_StoI             # rate of change for cumulative incidence\n      \n        St <- St + dS                # update the St\n        It <- It + dI                # update the It \n        Rt <- Rt + dR                # update the Rt\n        CIt <- CIt + dCI             # update the CIt\n      }\n      S[i] <- St                     # put St in the vector \n      I[i] <- It                     # put It in the vector \n      R[i] <- Rt                     # put Rt in the vector \n      CI[i] <- CIt                   # put CIt in the vector \n   }\n   # daily incidence from cumulative incidence\n   inc <- CI[2:tend] - CI[1:(tend-1)] \n   return(inc) \n   returnType(double(1)) # return type\n }\n)\n```\n:::\n\n\n모수 추정을 위해서 푸아송 분포를 이용하여 거짓 관찰값 (Y) 을 만들어보자.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create observation\nbeta <- 0.4 # true beta\nX <- sir_incidence(beta) # true daily incidence\nY <- rpois(length(X), lambda=X) # Poisson-distributed observation\n```\n:::\n\n\n아래와 같이 prior distribution,  likelihood, 그리고 posterior predictive check위해서 ypred 도 함께 구현한다. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# BUGS style code\ncode <- nimbleCode({\n  beta ~ T(dnorm(0, sd = 2), 0, 2) \t # prior for beta truncated at 0 and 2\n  mu[1:N] <- sir_incidence(beta)     # daily incidence from the model\n  for (i in 1:N) {\n    y[i] ~ dpois(mu[i])              # likelihood\n    ypred[i] ~ dpois(mu[i])          # posterior predictive value\n  }\n})\n```\n:::\n\n\n아래와 같이 초기 조건을 설정하고 모형을 구성한다.  빠른 실행을 위해서 컴파일 한다.\n\n::: {.cell}\n\n```{.r .cell-code}\n# constants, data, and initial values\nconstants <- list(N = length(Y))      # number of observation\ndata <- list(y = Y)                   # observation\ninits <- list(beta = 0.1)             # starting point for beta  \n\n# create the model object\nsir_model <- nimbleModel(code = code,\n                         constants = constants,\n                         data = data,\n                         inits = inits,\n                         check = FALSE)\n\nsirMCMC <- buildMCMC(sir_model, monitors=c('beta','ypred'))\nCsir <- compileNimble(sir_model)\nCsirMCMC <- compileNimble(sirMCMC, project=Csir)\n\n# thining interval was chosen based on previous analyses of ACF\nsamples <- runMCMC(CsirMCMC, niter=5000, thin=10, nburnin=1000)\n# saveRDS(samples, \"samples_nimble_20231125e.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsamples <- readRDS(\"samples_nimble_20231125e.rds\")\nplot(samples[,1], type=\"l\", ylab=expression(beta), xlab=\"Iterations\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n$\\beta$ 의 posterior distribution과 거짓 자료를 만들기 위해 사용했던 $\\beta$값 (빨간색)을 비교해보자. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nextrafont::loadfonts(\"win\", quiet=TRUE)\ntheme_set(hrbrthemes::theme_ipsum_rc(base_size=14, subtitle_size=16, axis_title_size=12))\n\nsamples |> \n  as.data.frame() |> \n  ggplot()+\n  geom_histogram(aes(x=beta, fill=\"posterior\"))+\n  geom_vline(aes(xintercept=0.4, color=\"true\"), linewidth=1.2)+\n  labs(x=expression(beta), y=\"frequency\")+\n  scale_fill_manual(\"\", values=c(\"posterior\"=\"grey\"))+\n  scale_color_manual(\"\", values=c(\"true\"=\"firebrick\"))+\n  theme(legend.position = \"bottom\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n#### Posterior predictive check\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# posterior predictive check\nnsamp <- nrow(samples)\ndf <- data.frame(time=rep(1:99, nsamp+1), \n                 name=c(rep(1:nsamp, each=99),rep(\"data\",99)))\ndf$value <- c(c(t(samples[,2:100])), Y)\n\n\nlibrary(dplyr)\nggplot(df)+\n  geom_line(data=filter(df, name!=\"data\"), aes(x=time, y=value, group=name,\n            color=\"posterior predictive values\"))+\n  geom_point(data=filter(df, name==\"data\"), aes(x=time, y=value, color=\"data\"),\n             size=1.2) +\n  labs(x='Time (day)', y='Daily infected')+\n  scale_color_manual(\"\",values=c(\"posterior predictive values\"=\"grey\",\n                                 \"data\"=\"firebrick\"))+\n  theme(legend.position = \"bottom\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# ggsave(\"nimble_ppc_incidence.png\", gg, units=\"in\", width=3.4*2, height=2.7*2)\n```\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}