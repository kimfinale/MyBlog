{
  "hash": "aac19eb087ae457f80e94b95313d6b8c",
  "result": {
    "markdown": "---\ntitle: \"Waning of vaccine effectiveness\"\nauthor: \"Jong-Hoon Kim\"\ndate: \"2024-04-04\"\ncategories: [vaccine efficacy, clinical trial, SEIR]\nimage: \"vacc_eff_waning.png\"\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n\nThe protection derived from vaccination often wanes over time and require the second or the third doses (so-called booster doses). For example, the [study](https://pubmed.ncbi.nlm.nih.gov/8852414/) showed the efficacy of cholera vaccines over five years. The vaccine efficacy (VE) over the period seems to indicate that the VE wanes over time. In this post, we will develop a $SEIR$ model to illustrate the waning of vaccine-derived immunity.\n\n#### $SEIR$ model with vaccination\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseir_vacc_trial_jl <- function(u, p, t){\n  # vaccine recipients lose partial immunity over time.\n  # this is implemented in a way that individuals in the V state\n  # decreases and transitions to the S state\n  S <- u[1]; E <- u[2]; I <- u[3]; R <- u[4]; C <- u[5]\n \n  # vaccinated cohort\n  V <- u[6]; # vaccinated and partially protected\n  VS <- u[7]; # vaccinated but immunity waned and fully susceptible\n  VE <- u[8]; VI <- u[9]; VR <- u[10]; VC <- u[11]\n  \n  pop <- S + E + I + R\n  popV <- V + VS + VE + VI + VR\n\n  epsilon <- p[1] # 1/latent period\n  gamma <- p[2] # 1/duration of infectiousness\n  beta <- p[3] # transmission rate\n  mu <- p[4] # death rate is applied and population size decreases over time\n  omega <- p[5] # 1 / duration of natural immunity\n  omega_v <- p[6] # 1 / duration of partial vaccine-derived immunity\n  ve <- p[7] # vaccine efficacy\n  # vaccinated and unvaccinated population mix randomly\n  foi <- beta * (I+VI) / (pop + popV) # force of infection\n  \n  muEI <- epsilon\n  muIR <- gamma\n  muRS <- omega\n  muVS <- omega_v\n  \n  # differential equations\n  dS <- - foi*S + muRS*R - mu*S\n  dE <- foi*S - muEI*E - mu*E\n  dI <- muEI*E - muIR*I - mu*I\n  dR <- muIR*I - muRS*R - mu*R\n  dC <- muEI*E\n  \n  dV <- - foi*(1-ve)*V - muVS*V - mu*V\n  dVS <- - foi*VS + muVS*V + muRS*VR - mu*VS \n  dVE <- foi*((1-ve)*V + VS) - muEI*VE - mu*VE\n  dVI <- muEI*VE - muIR*VI - mu*VI\n  dVR <- muIR*VI - muRS*VR - mu*VR\n  dVC <- muEI*VE\n  \n  return(c(dS,dE,dI,dR,dC,dV,dVS,dVE,dVI,dVR,dVC))\n}\n```\n:::\n\n\n`diffeqr` package is used use Julia's `DifferentialEquations` library\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(diffeqr)\nde <- diffeqr::diffeq_setup()\n```\n:::\n\n\nWe assume that cholera transmission is in the steady state in the setting where the vaccine efficacy trial is examined. Algebraic [solutions](https://www.jonghoonk.com/posts/cholera_seir_eqn/) to the steady states (shown below) are used as initial conditions to generate initial conditions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSs <- \"((gamma + mu) * (epsilon + mu)) / (beta * epsilon)\"\nEs <- \"- ((gamma + mu) * (mu + omega) * ((gamma + mu) * (epsilon + mu) - beta * epsilon)) / (beta * epsilon * (gamma * (epsilon + mu + omega) + (epsilon + mu) * (mu + omega)))\"\n\nIs <- \"((mu + omega) * (beta * epsilon - (gamma + mu) * (epsilon + mu))) / (beta * omega * (gamma + epsilon + mu) + beta * (gamma + mu) * (epsilon + mu))\"\nRs <- \"(beta * gamma * epsilon - gamma * (gamma + mu) * (epsilon + mu)) / (beta * omega * (gamma + epsilon + mu) + beta * (gamma + mu) * (epsilon + mu))\"\n```\n:::\n\n\n#### Simulation of a clinical trial\n\nThe basic idea is to use the steady states as initial conditions and therefore, cholera transmission is sustained as new susceptibles are supplied through birth and waning of vaccine-derived and natural immunity. In this setting, a clinical trial is implemented by moving some portion of the population to the vaccinated cohort. Note that the proportion of the vaccinated population, $f$, is important in the subsequent dynamics. For example, we [know](https://www.jonghoonk.com/posts/critical_vacc_threshold/index.html) that if $f> 1- \\frac{1}{R_0}$, cholera infections will die out. In this case, we can not measure the relative risk of cholera among vaccinated and unvaccinated population over a period based on the cumulative incidence. Even if $f < 1- \\frac{1}{R_0}$, moving some portion of the population into vaccinated states will perturb the steady states that were determined based on and a series of outbreaks may follow before the system reaches new steady states eventually.\n\nSince our objective is to vaccine efficacy in this dynamic population based on cumulative incidence among vaccinated and unvaccinated people, and we used the steady states without the vaccinated population, we can set the proportion of the vaccinated population small that the system more or less maintains the states without vaccination. Wh\n\n\n::: {.cell}\n\n```{.r .cell-code}\nN <- 1e5 # unvaccinated population\nf <- 1e-4 # a very small proportion of the population is vaccinated\nR0 <- 2\nepsilon <- 1/1.4\ngamma <- 1/2\nbeta <- R0*gamma\n# mu <- 1/(65*365) # natural death rate\nmu <- 0 # natural death rate\nomega <- 1/(40*365) # natural immunity waning rate\nomega_v <- 1/(10*365) # vaccine-derived immunity waning rate\nve <- 0.7 # vaccine efficacy (instantaneous hazard ratio)\n# vaccine efficacy based on CI will differ and we will eventually estimate\n# this parameter along with omega_v\nparams <- c(epsilon=epsilon, gamma=gamma, beta=beta, mu=mu, \n            omega=omega, omega_v=omega_v, ve=ve)\n# steady states for given parameters\nstates0 <- list(S=Ss, E=Es, I=Is, R=Rs)\nsteadys0 <- sapply(states0, function(x) eval(parse(text = x)))\n# initial distribution of the population across the states\nu0 <- c(steadys0*N,C=0,V=0,VS=0,VE=0,VI=0,VR=0,VC=0)\nu0[c(\"V\",\"VE\",\"VI\",\"VR\")] <- as.numeric(steadys0*N*f/(1-f))\n\ntend <- 20.0*365 # measure vaccin\ntspan <- c(0.0, tend)\n\nprob <- de$ODEProblem(seir_vacc_trial_jl, u0, tspan, params)\nsol <- de$solve(prob, de$Tsit5(), saveat=1)\n\nmat <- sapply(sol$u, identity)\nudf <- as.data.frame(t(mat))\nout <- cbind(data.frame(t=sol$t), udf)\nnames(out) <- c(\"t\",\"S\",\"E\",\"I\",\"R\",\"C\",\"V\",\"VS\",\"VE\",\"VI\",\"VR\",\"VC\")\n# cumulative incidence\nplot(1:nrow(out)/365, out[,\"C\"], type=\"l\", ylab=\"cumulative incidence\", xlab=\"year\", col=\"black\")\nlines(1:nrow(out)/365,out[,\"VC\"], col=\"firebrick\")\nlegend(\"topleft\", \n  legend=c(\"No vaccine\", \"Vaccine\"), \n  col=c(\"black\", \"firebrick\"), \n  lty= 1,\n  bty = \"n\", \n  cex = 1.0, \n  text.col = \"black\", \n  horiz = F , \n  inset = c(0.02,0.02))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\nMeasure vaccine impact\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnovacc <- c(\"S\",\"E\",\"I\",\"R\")\nvacc <- c(\"V\",\"VS\",\"VE\",\"VI\",\"VR\")\ndve <- rep(NA, nrow(out)) # direct vaccine effectiveness measured daily\nfor(i in 1:nrow(out)){\n  dve[i] <- 1 - (out[i,\"VC\"]/sum(out[i,vacc]))/(out[i,\"C\"]/sum(out[i,novacc]))\n}\nplot(1:length(dve)/365,dve, type=\"l\", ylab=\"direct VE\", xlab=\"year\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n### Estimating VE and $\\omega_V$\n\nLet's suppose we want to the following dataset showing the vaccine effec\n\n\n::: {.cell}\n\n```{.r .cell-code}\nve_obs <- c(76,72,68,63,58,52,46,39,32,24,15)/100\n```\n:::\n\n\nCreate a function to measure vaccine efficacy from the model based on cumulative incidence\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmeasure_vacc_eff <- function(p, times, N=1e5, f=1e-4){\n  params[\"ve\"] <- p[1]\n  params[\"omega_v\"] <- p[2]\n  u0 <- c(steadys0*N,C=0,V=N,VS=0,VE=0,VI=0,VR=0,VC=0)\n  u0[c(\"V\",\"VE\",\"VI\",\"VR\")] <- as.numeric(steadys0*N*f/(1-f))\n  prob <- de$ODEProblem(seir_vacc_trial_jl, u0, c(0.0, max(times)+1), params)\n  sol <- de$solve(prob, de$Tsit5(), saveat=1)\n  mat <- sapply(sol$u, identity)\n  udf <- as.data.frame(t(mat))\n  out <- cbind(data.frame(t=sol$t), udf)\n  names(out) <- c(\"t\",\"S\",\"E\",\"I\",\"R\",\"C\",\n                  \"V\",\"VS\",\"VE\",\"VI\",\"VR\",\"VC\")\n  novacc <- c(\"S\",\"E\",\"I\",\"R\")\n  vacc <- c(\"V\",\"VS\",\"VE\",\"VI\",\"VR\")\n  \n  ve_sim <- rep(NA, length(times))\n  for (i in 1:length(times)) {\n    ve_sim[i] <- 1 - \n      ((out[times[i],\"VC\"])/sum(out[times[i],vacc])) / \n      ((out[times[i],\"C\"])/sum(out[times[i],novacc]))\n  }\n  return(ve_sim)\n}\n```\n:::\n\n\nDefine sum of squared difference to evaluate the difference between the model and the observation\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# the initial VE is not measured from the model\ntimes = seq(6,by=6,length.out=10)*30 # times to measure VE\nssq <- function(p){\n  ve_sim <- measure_vacc_eff(p, times=times)\n  sum((ve_obs - c(p[1],ve_sim))^2)  \n}\n# check for some predetermined ve and omega\n# ssq(p=c(0.8,1/3650)) must be smaller than ssq(p=c(0.4,1/365))\nssq(p=c(0.8,1/3650))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.5765074\n```\n:::\n\n```{.r .cell-code}\nssq(p=c(0.4,1/365))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.260319\n```\n:::\n:::\n\n\nUse the `nlminb` to identify the parameter values that minimize the ssq.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit <- nlminb(c(0.2, 1/(2*365)), objective=ssq, \n              lower=c(0.1,1/(1000*365)),\n              upper=c(0.99,0.99))\nve_obs\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 0.76 0.72 0.68 0.63 0.58 0.52 0.46 0.39 0.32 0.24 0.15\n```\n:::\n\n```{.r .cell-code}\nround(c(fit$par[1], measure_vacc_eff(p=fit$par, times)), digits=2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 0.83 0.73 0.65 0.58 0.52 0.46 0.42 0.38 0.34 0.31 0.29\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# png(\"vacc_eff_waning.png\")\nplot(0:10/2, ve_obs, col=\"firebrick\", \n     ylim=c(0,1), xlab=\"year\", ylab=\"direct VE\",\n     type=\"p\", pch=0)\n\nlines(0:10/2,c(fit$par[1], measure_vacc_eff(p=fit$par, times)),\n      col=\"black\")\nlegend(\"topright\", \n  legend=c(\"Data\", \"Model\"), \n  col=c(\"firebrick\", \"black\"), \n  lty= c(0,1),\n  pch=c(0,NA),\n  bty = \"n\", \n  cex = 1.0, \n  text.col = \"black\", \n  horiz = F , \n  inset = c(0.02,0.02))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# dev.off()\n```\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}